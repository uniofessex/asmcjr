% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mlsmu6.R
\name{mlsmu6}
\alias{mlsmu6}
\title{Multidimensional Scaling with Missing Data (mlsmu6)}
\usage{
mlsmu6(input, ndim = 2, cutoff = 5, tol = 5e-04, maxit = 50, id = NULL)
}
\arguments{
\item{input}{A numeric matrix representing the data to be scaled. Rows correspond to individuals, and columns correspond to stimuli. Missing values (NA) are allowed.}

\item{ndim}{An integer specifying the number of dimensions to estimate. Default is 2.}

\item{cutoff}{An integer specifying the minimum number of non-missing values required for a row to be included in the analysis. Default is 5.}

\item{tol}{A numeric value specifying the convergence tolerance for the iterative procedure. Default is 0.0005.}

\item{maxit}{An integer specifying the maximum number of iterations allowed. Default is 50.}

\item{id}{An optional vector of identifiers for the rows (individuals) of the input matrix. If provided, it will be added to the output.}
}
\value{
A list of class \code{mlsmu6} containing:
\item{inds}{A data frame with the estimated positions of the individuals in the lower-dimensional space.}
\item{stims}{A data frame with the estimated positions of the stimuli in the lower-dimensional space.}
\item{iter}{A matrix tracking the error sum of squares over iterations.}
}
\description{
The \code{mlsmu6} function performs multidimensional scaling (MDS) on data with missing values using an iterative approach to minimize the error sum of squares. It returns the estimated positions of stimuli and individuals in a lower-dimensional space.
}
\details{
The function starts by centering the input data, then applies singular value decomposition (SVD) to initialize the positions of the stimuli and individuals. It iteratively adjusts these positions to minimize the error sum of squares. The process stops when the change in the error sum of squares falls below the specified tolerance (\code{tol}) or the maximum number of iterations (\code{maxit}) is reached.
}
\examples{
\dontrun{
# Load the interest1981 dataset and prepare the input matrix
data(interest1981)
input <- as.matrix(interest1981[, 9:38])
cutoff <- 5
input <- input[rowSums(!is.na(input)) >= cutoff, ]
input <- (100 - input) / 50
input2 <- input * input
input2[is.na(input)] <- (mean(input, na.rm = TRUE))^2
inputDC <- doubleCenterRect(input2)

# Perform SVD and initialize positions
xsvd <- svd(inputDC)
ndim <- 2
stims <- xsvd$v[, 1:ndim]
inds <- xsvd$u[, 1:ndim]
for (i in 1:ndim) {
  stims[, i] <- stims[, i] * sqrt(xsvd$d[i])
  inds[, i] <- inds[, i] * sqrt(xsvd$d[i])
}

# Run mlsmu6 to get the MDS solution
out <- mlsmu6(input = interest1981[, 9:38], ndim = 2, cutoff = 5,
              id = factor(interest1981$party, labels = c("D", "R")))

# Inspect the results
print(out$inds)
print(out$stims)
plot(out$iter, type = "b", main = "Error Sum of Squares Over Iterations")
}

}
